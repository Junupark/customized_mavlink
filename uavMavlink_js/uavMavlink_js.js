/*
MAVLink protocol implementation for node.js (auto-generated by mavgen_javascript.py)

Generated from: ascluav.xml

Note: this file has been auto-generated. DO NOT EDIT
*/

jspack = require("jspack").jspack,
    _ = require("underscore"),
    events = require("events"),
    util = require("util");

// Add a convenience method to Buffer
Buffer.prototype.toByteArray = function () {
  return Array.prototype.slice.call(this, 0)
}

mavlink = function(){};

// Implement the X25CRC function (present in the Python version through the mavutil.py package)
mavlink.x25Crc = function(buffer, crcIN) {

    var bytes = buffer;
    var crcOUT = crcIN || 0xffff;
    _.each(bytes, function(e) {
        var tmp = e ^ (crcOUT & 0xff);
        tmp = (tmp ^ (tmp << 4)) & 0xff;
        crcOUT = (crcOUT >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
        crcOUT = crcOUT & 0xffff;
    });
    return crcOUT;

}

mavlink.WIRE_PROTOCOL_VERSION = "2.0";

mavlink.MAVLINK_TYPE_CHAR     = 0
mavlink.MAVLINK_TYPE_UINT8_T  = 1
mavlink.MAVLINK_TYPE_INT8_T   = 2
mavlink.MAVLINK_TYPE_UINT16_T = 3
mavlink.MAVLINK_TYPE_INT16_T  = 4
mavlink.MAVLINK_TYPE_UINT32_T = 5
mavlink.MAVLINK_TYPE_INT32_T  = 6
mavlink.MAVLINK_TYPE_UINT64_T = 7
mavlink.MAVLINK_TYPE_INT64_T  = 8
mavlink.MAVLINK_TYPE_FLOAT    = 9
mavlink.MAVLINK_TYPE_DOUBLE   = 10

mavlink.MAVLINK_IFLAG_SIGNED = 0x01

// Mavlink headers incorporate sequence, source system (platform) and source component. 
mavlink.header = function(msgId, mlen, seq, srcSystem, srcComponent, incompat_flags=0, compat_flags=0,) {

    this.mlen = ( typeof mlen === 'undefined' ) ? 0 : mlen;
    this.seq = ( typeof seq === 'undefined' ) ? 0 : seq;
    this.srcSystem = ( typeof srcSystem === 'undefined' ) ? 0 : srcSystem;
    this.srcComponent = ( typeof srcComponent === 'undefined' ) ? 0 : srcComponent;
    this.msgId = msgId
    this.incompat_flags = incompat_flags
    this.compat_flags = compat_flags

}

mavlink.header.prototype.pack = function() {
    if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
        return jspack.Pack('BBBBBBBHB', [253, this.mlen, this.incompat_flags, this.compat_flags, this.seq, this.srcSystem, this.srcComponent, ((this.msgId & 0xFF) << 8) | ((this.msgId >> 8) & 0xFF), this.msgId>>16]);
    }
    else {
        return jspack.Pack('BBBBBB', [253, this.mlen, this.seq, this.srcSystem, this.srcComponent, this.msgId]);
    }
}

// Base class declaration: mavlink.message will be the parent class for each
// concrete implementation in mavlink.messages.
mavlink.message = function() {};

// Convenience setter to facilitate turning the unpacked array of data into member properties
mavlink.message.prototype.set = function(args) {
    _.each(this.fieldnames, function(e, i) {
        this[e] = args[i];
    }, this);
};

// This pack function builds the header and produces a complete MAVLink message,
// including header and message CRC.
mavlink.message.prototype.pack = function(mav, crc_extra, payload) {

    this.payload = payload;
    var plen = this.payload.length;
    //in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
    // variable length arrays and smaller packets
    if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
        while (plen > 1 && this.payload[plen-1] == 0) {
                plen = plen - 1;
        }
        this.payload = this.payload.slice(0, plen);
    }
    var incompat_flags = 0;
    this.header = new mavlink.header(this.id, this.payload.length, mav.seq, mav.srcSystem, mav.srcComponent, incompat_flags, 0,);    
    this.msgbuf = this.header.pack().concat(this.payload);
    var crc = mavlink.x25Crc(this.msgbuf.slice(1));

    // For now, assume always using crc_extra = True.  TODO: check/fix this.
    crc = mavlink.x25Crc([crc_extra], crc);
    this.msgbuf = this.msgbuf.concat(jspack.Pack('<H', [crc] ) );
    return this.msgbuf;

}


// enums

// ASCL_CATEGORY
mavlink.ASCL_CATEGORY_NAVIGATION = 0 // Category Navigation
mavlink.ASCL_CATEGORY_CONTROL = 1 // Category Control
mavlink.ASCL_CATEGORY_GUIDANCE = 2 // Category Guidance
mavlink.ASCL_CATEGORY_MISSION = 3 // Category Mission
mavlink.ASCL_CATEGORY_RESERVED1 = 4 // Category reserved
mavlink.ASCL_CATEGORY_RESERVED2 = 5 // Category reserved
mavlink.ASCL_CATEGORY_RESERVED3 = 6 // Category reserved
mavlink.ASCL_CATEGORY_ENUM_END = 7 // 

// ASCL_PARAM_ID
mavlink.ASCL_PARAM_ID_NAV_COV_P0_QUAT = 0 // Covariance P0 for quaternions
mavlink.ASCL_PARAM_ID_NAV_COV_P0_EULER_TILT = 1 // Covariance P0 for roll,pitch
mavlink.ASCL_PARAM_ID_NAV_COV_P0_EULER_HEADING = 2 // Covariance P0 for heading
mavlink.ASCL_PARAM_ID_NAV_COV_P0_HOR_VEL = 3 // Covariance P0 for horizontal velocity
mavlink.ASCL_PARAM_ID_NAV_COV_P0_VER_VEL = 4 // Covariance P0 for vertical velocity
mavlink.ASCL_PARAM_ID_NAV_COV_P0_HOR_POS = 5 // Covariance P0 for horizontal position
mavlink.ASCL_PARAM_ID_NAV_COV_P0_VER_POS = 6 // Covariance P0 for altitude
mavlink.ASCL_PARAM_ID_NAV_COV_P0_GYRO_BIAS = 7 // Covariance P0 for gyro bias
mavlink.ASCL_PARAM_ID_NAV_COV_P0_ACC_BIAS = 8 // Covariance P0 for acc bias
mavlink.ASCL_PARAM_ID_NAV_COV_P0_MAG_NED = 9 // Covariance P0 for NED magnetic flux
mavlink.ASCL_PARAM_ID_NAV_COV_P0_MAG_BIAS = 10 // Covariance P0 for mag bias
mavlink.ASCL_PARAM_ID_NAV_COV_Q_GYRO = 16 // Covariance Q for delta angle
mavlink.ASCL_PARAM_ID_NAV_COV_Q_GYRO_BIAS = 17 // Covariance Q for gyro bias
mavlink.ASCL_PARAM_ID_NAV_COV_Q_ACC = 18 // Covariance Q for delta velocity
mavlink.ASCL_PARAM_ID_NAV_COV_Q_ACC_BIAS = 19 // Covariance Q for acc bias
mavlink.ASCL_PARAM_ID_NAV_COV_Q_MAG_NED = 20 // Covariance Q for NED magnetic flux
mavlink.ASCL_PARAM_ID_NAV_COV_Q_MAG_BIAS = 21 // Covariance Q for mag bias
mavlink.ASCL_PARAM_ID_NAV_COV_R_GPS_HOR_POS = 32 // Covariance R for NE position of GPS lat, long, height converted into
                        // NED
mavlink.ASCL_PARAM_ID_NAV_COV_R_GPS_VER_POS = 33 // Covariance R for D position of GPS lat, long, height converted into
                        // NED
mavlink.ASCL_PARAM_ID_NAV_COV_R_GPS_VEL = 34 // Covariance R for GPS velocity_ned
mavlink.ASCL_PARAM_ID_NAV_COV_R_BARO_ALT = 35 // Covariance R for barometric altitude
mavlink.ASCL_PARAM_ID_NAV_COV_R_MAG_BODY = 36 // Covariance R for magnetometer measurement
mavlink.ASCL_PARAM_ID_NAV_COV_R_MAG_DECLINATION = 37 // Covariance R for magnetic declination
mavlink.ASCL_PARAM_ID_NAV_COV_R_AHRS = 38 // Covariance R for AHRS
mavlink.ASCL_PARAM_ID_CTRL_GAIN_P_RATE_P = 4096 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_I_RATE_P = 4097 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_D_RATE_P = 4098 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_P_RATE_Q = 4099 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_I_RATE_Q = 4100 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_D_RATE_Q = 4101 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_P_RATE_R = 4102 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_I_RATE_R = 4103 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_D_RATE_R = 4104 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_P_ATT_ROLL = 4105 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_I_ATT_ROLL = 4106 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_D_ATT_ROLL = 4107 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_P_ATT_PITCH = 4108 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_I_ATT_PITCH = 4109 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_D_ATT_PITCH = 4110 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_P_ATT_YAW = 4111 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_I_ATT_YAW = 4112 // 
mavlink.ASCL_PARAM_ID_CTRL_GAIN_D_ATT_YAW = 4113 // 
mavlink.ASCL_PARAM_ID_GUID_PN_CONSTANT = 8192 // Proportional constant of PN guidance, 3~5
mavlink.ASCL_PARAM_ID_GUID_MAXIMUM_PULLUP_G = 8193 // Constraint on maximum acceleration represented in "g"
mavlink.ASCL_PARAM_ID_MISSION_BATTERY_RTB = 12288 // Vehicle should perform RTB when battery level is below this
mavlink.ASCL_PARAM_ID_ENUM_END = 12289 // 

// ASCL_PARAM_TYPE
mavlink.ASCL_PARAM_TYPE_UINT8 = 1 // 8-bit unsigned integer
mavlink.ASCL_PARAM_TYPE_INT8 = 2 // 8-bit signed integer
mavlink.ASCL_PARAM_TYPE_UINT16 = 3 // 16-bit unsigned integer
mavlink.ASCL_PARAM_TYPE_INT16 = 4 // 16-bit signed integer
mavlink.ASCL_PARAM_TYPE_UINT32 = 5 // 32-bit unsigned integer
mavlink.ASCL_PARAM_TYPE_INT32 = 6 // 32-bit signed integer
mavlink.ASCL_PARAM_TYPE_UINT64 = 7 // 64-bit unsigned integer
mavlink.ASCL_PARAM_TYPE_INT64 = 8 // 64-bit signed integer
mavlink.ASCL_PARAM_TYPE_REAL32 = 9 // 32-bit floating-point
mavlink.ASCL_PARAM_TYPE_REAL64 = 10 // 64-bit floating-point
mavlink.ASCL_PARAM_TYPE_ENUM_END = 11 // 

// ASCL_PARAM_RESULT
mavlink.ASCL_PARAM_RESULT_ACCEPTED = 1 // Parameter published through ASCL_PARAM_SET is accepted
mavlink.ASCL_PARAM_RESULT_REJECTED = 2 // Parameter published through ASCL_PARAM_SET is rejected since it's
                        // invalid
mavlink.ASCL_PARAM_RESULT_INVALID_ID = 3 // Parameter identified through both ASCL_PARAM_SET/ASCL_PARAM_REQUEST is
                        // not accessible
mavlink.ASCL_PARAM_RESULT_RESPONSE = 4 // Parameter is correctly returned in response of ASCL_PARAM_REQUEST
mavlink.ASCL_PARAM_RESULT_ENUM_END = 5 // 

// ASCL_EKF_FUSION
mavlink.ASCL_EFK_FUSION_NONE = 0 // 
mavlink.ASCL_EFK_FUSION_RESERVED2 = 1 // 
mavlink.ASCL_EFK_FUSION_RESERVED1 = 2 // 
mavlink.ASCL_EFK_FUSION_AHRS = 4 // 
mavlink.ASCL_EFK_FUSION_MAG_DECL = 8 // 
mavlink.ASCL_EFK_FUSION_MAG_XYZ = 16 // 
mavlink.ASCL_EFK_FUSION_BARO_ALT = 32 // 
mavlink.ASCL_EFK_FUSION_GPS_VEL = 64 // 
mavlink.ASCL_EFK_FUSION_GPS_POS = 128 // 
mavlink.ASCL_EKF_FUSION_ALL = 255 // 
mavlink.ASCL_EKF_FUSION_ENUM_END = 256 // 

// ASCL_SENSOR_CALIBRATION
mavlink.ASCL_SENSOR_CALIBRATION_NONE = 0 // no designated calibration
mavlink.ASCL_SENSOR_CALIBRATION_MAG = 1 // 
mavlink.ASCL_SENSOR_CALIBRATION_HEIGHT = 2 // 
mavlink.ASCL_SENSOR_CALIBRATION_ACC = 4 // 
mavlink.ASCL_SENSOR_CALIBRATION_GYRO = 8 // 
mavlink.ASCL_SENSOR_CALIBRATION_RESERVED4 = 16 // 
mavlink.ASCL_SENSOR_CALIBRATION_RESERVED3 = 32 // 
mavlink.ASCL_SENSOR_CALIBRATION_RESERVED2 = 64 // 
mavlink.ASCL_SENSOR_CALIBRATION_RESERVED1 = 128 // 
mavlink.ASCL_SENSOR_CALIBRATION_ALL = 129 // 
mavlink.ASCL_SENSOR_CALIBRATION_ENUM_END = 130 // 

// ASCL_COMMAND
mavlink.ASCL_COMMAND_NAV_RESET_COVARIANCE_FROM_TO = 0 // Reset Covariance P of EKF within designated indexes.
mavlink.ASCL_COMMAND_NAV_RESET_COVARIANCE_ALL = 1 // Reset covariance of EKF22
mavlink.ASCL_COMMAND_NAV_RESET_STATE_FROM_TO = 2 // Reset selected navigation state of EKF22
mavlink.ASCL_COMMAND_NAV_RESET_STATE_ALL = 3 // Reset navigation state of EKF22
mavlink.ASCL_COMMAND_NAV_SET_FUSION = 4 // Turn on/off fusion flag of fusible data
mavlink.ASCL_COMMAND_NAV_CALIBRATE_SENSORS = 5 // Calibrate designated sensor(s)
mavlink.ASCL_COMMAND_NAV_USE_CALIBRATED = 6 // Flag whether or not to use FC's calibration data
mavlink.ASCL_COMMAND_NAV_OVERRIDE_CALIBRATED = 7 // Override FC's calibration data into offline calibrated value
mavlink.ASCL_COMMAND_NAV_SET_HOME = 8 // Set home position of FC as command
mavlink.ASCL_COMMAND_NAV_GET_HOME = 9 // Request for home position of FC
mavlink.ASCL_COMMAND_ENUM_END = 10 // 

// ASCL_COMMAND_RESULT
mavlink.ASCL_COMMAND_RESULT_OK = 1 // Command is OK/applied
mavlink.ASCL_COMMAND_RESULT_ERR = 2 // Generic Error
mavlink.ASCL_COMMAND_RESULT_ERR_REJECTED = 3 // Command is refused by subscriber as it's not applicable at the moment
mavlink.ASCL_COMMAND_RESULT_ERR_UNKNOWN = 4 // Command is refused by subscriber as it's unknown command
mavlink.ASCL_COMMAND_RESULT_ENUM_END = 5 // 

// message IDs
mavlink.MAVLINK_MSG_ID_BAD_DATA = -1
mavlink.MAVLINK_MSG_ID_ASCL_PARAM_SET = 53232
mavlink.MAVLINK_MSG_ID_ASCL_PARAM_REQUEST = 53233
mavlink.MAVLINK_MSG_ID_ASCL_PARAM_VALUE = 53234
mavlink.MAVLINK_MSG_ID_ASCL_COMMAND_SEND_FI = 53248
mavlink.MAVLINK_MSG_ID_ASCL_COMMAND_SEND_F = 53249
mavlink.MAVLINK_MSG_ID_ASCL_COMMAND_ACK = 53250
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_REGULAR_VALUE = 55296
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_REGULAR_COV = 55297
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_ATT = 55298
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_VEL_POS = 55299
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_REFERNCE = 55300
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_HOME = 55301
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_MAG = 53400
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_IMU = 53401
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_GPS = 53402
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_BARO = 53403
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_GPS_INS = 53404
mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_GENERAL = 53410
mavlink.MAVLINK_MSG_ID_ASCL_RC_CHANNELS_RAW = 53500
mavlink.MAVLINK_MSG_ID_ASCL_RC_CHANNELS_SCALED = 53501
mavlink.MAVLINK_MSG_ID_ASCL_PWM_OUT = 53502

mavlink.messages = {};

/* 
Set a Parameter that corresponds to ASCL_PARAM. SUBSCRIBER of this
message should PUBLISH ASCL_PARAM_VALUE in order to let PUBLISHER know

                param_id                  : ID of a parameter (uint16_t)
                param_value               : Value of a parameter (float)
                param_type                : Type of a parameter (uint8_t)

*/
mavlink.messages.ascl_param_set = function(param_id, param_value, param_type) {

    this.format = '<fHB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_PARAM_SET;
    this.order_map = [1, 0, 2];
    this.crc_extra = 117;
    this.name = 'ASCL_PARAM_SET';

    this.fieldnames = ['param_id', 'param_value', 'param_type'];


    this.set(arguments);

}
        
mavlink.messages.ascl_param_set.prototype = new mavlink.message;

mavlink.messages.ascl_param_set.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.param_value, this.param_id, this.param_type]));
}

/* 


                param_id                  : ID of a parameter (uint16_t)

*/
mavlink.messages.ascl_param_request = function(param_id) {

    this.format = '<H';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_PARAM_REQUEST;
    this.order_map = [0];
    this.crc_extra = 50;
    this.name = 'ASCL_PARAM_REQUEST';

    this.fieldnames = ['param_id'];


    this.set(arguments);

}
        
mavlink.messages.ascl_param_request.prototype = new mavlink.message;

mavlink.messages.ascl_param_request.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.param_id]));
}

/* 
Publish parameter value with corresponding status result @ either
case. 1.ASCL_PARAM_SET > value + status: rejected/accepted,
2.ASCL_PARAM_REQUEST > value + response of request

                param_id                  : ID of a parameter (uint16_t)
                param_value               : Value of a parameter (float)
                param_type                : Type of a parameter (uint8_t)
                result                    : Status of a parameter (uint8_t)

*/
mavlink.messages.ascl_param_value = function(param_id, param_value, param_type, result) {

    this.format = '<fHBB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_PARAM_VALUE;
    this.order_map = [1, 0, 2, 3];
    this.crc_extra = 197;
    this.name = 'ASCL_PARAM_VALUE';

    this.fieldnames = ['param_id', 'param_value', 'param_type', 'result'];


    this.set(arguments);

}
        
mavlink.messages.ascl_param_value.prototype = new mavlink.message;

mavlink.messages.ascl_param_value.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.param_value, this.param_id, this.param_type, this.result]));
}

/* 
Message encoding a command with parameters

                command_id                : Command ID (uint16_t)
                option                    : command option, see ASCL_COMMAND enum (uint16_t)
                paramf1                   : PARAM1, float, see ASCL_COMMAND enum (float)
                paramf2                   : PARAM2, float, see ASCL_COMMAND enum (float)
                paramf3                   : PARAM3, float, see ASCL_COMMAND enum (float)
                parami1                   : PARAM1, int, see ASCL_COMMAND enum, e.g. local: x position in meters * 1e4, global: latitude in degrees * 10^7 (int32_t)
                parami2                   : PARAM2, int, see ASCL_COMMAND enum, e.g. local: y position in meters * 1e4, global: longitude in degrees * 10^7 (int32_t)
                parami3                   : PARAM3, int, see ASCL_COMMAND enum, e.g. z position: global: altitude in meters (relative or absolute, depending on frame). (int32_t)

*/
mavlink.messages.ascl_command_send_fi = function(command_id, option, paramf1, paramf2, paramf3, parami1, parami2, parami3) {

    this.format = '<fffiiiHH';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_COMMAND_SEND_FI;
    this.order_map = [6, 7, 0, 1, 2, 3, 4, 5];
    this.crc_extra = 145;
    this.name = 'ASCL_COMMAND_SEND_FI';

    this.fieldnames = ['command_id', 'option', 'paramf1', 'paramf2', 'paramf3', 'parami1', 'parami2', 'parami3'];


    this.set(arguments);

}
        
mavlink.messages.ascl_command_send_fi.prototype = new mavlink.message;

mavlink.messages.ascl_command_send_fi.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.paramf1, this.paramf2, this.paramf3, this.parami1, this.parami2, this.parami3, this.command_id, this.option]));
}

/* 
Message encoding a command with parameters

                command_id                : Command ID (uint16_t)
                option                    : command option, see ASCL_COMMAND enum (uint16_t)
                paramf1                   : PARAM1, float, see ASCL_COMMAND enum (float)
                paramf2                   : PARAM2, float, see ASCL_COMMAND enum (float)
                paramf3                   : PARAM3, float, see ASCL_COMMAND enum (float)
                paramf4                   : PARAM4, float, see ASCL_COMMAND enum (float)
                paramf5                   : PARAM5, float, see ASCL_COMMAND enum (float)
                paramf6                   : PARAM6, float, see ASCL_COMMAND enum (float)

*/
mavlink.messages.ascl_command_send_f = function(command_id, option, paramf1, paramf2, paramf3, paramf4, paramf5, paramf6) {

    this.format = '<ffffffHH';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_COMMAND_SEND_F;
    this.order_map = [6, 7, 0, 1, 2, 3, 4, 5];
    this.crc_extra = 216;
    this.name = 'ASCL_COMMAND_SEND_F';

    this.fieldnames = ['command_id', 'option', 'paramf1', 'paramf2', 'paramf3', 'paramf4', 'paramf5', 'paramf6'];


    this.set(arguments);

}
        
mavlink.messages.ascl_command_send_f.prototype = new mavlink.message;

mavlink.messages.ascl_command_send_f.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.paramf1, this.paramf2, this.paramf3, this.paramf4, this.paramf5, this.paramf6, this.command_id, this.option]));
}

/* 
Message encoding an acknoledgment of subscribed command

                command_id                : Command ID (uint16_t)
                result                    : Result of Command designated by Command ID (uint8_t)

*/
mavlink.messages.ascl_command_ack = function(command_id, result) {

    this.format = '<HB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_COMMAND_ACK;
    this.order_map = [0, 1];
    this.crc_extra = 123;
    this.name = 'ASCL_COMMAND_ACK';

    this.fieldnames = ['command_id', 'result'];


    this.set(arguments);

}
        
mavlink.messages.ascl_command_ack.prototype = new mavlink.message;

mavlink.messages.ascl_command_ack.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.command_id, this.result]));
}

/* 
Message encoding regular telemetry set

                timems                    : FC time in ms (uint32_t)
                pqr                       : Angular rate in rad/s (float)
                euler                     : Euler angle in deg (float)
                quat                      : Quaternion (float)
                acc                       : Linear acceleration in m/s2 (float)
                velNed                    : Velocity of a vehicle in NED frame in m/s (float)
                ned                       : NED position in m (float)
                llh                       : latitude/longitude/height in degE7/degE7/mm as integer (uint32_t)
                navStatus                 : navigational status. Filter validity/Sensor validity (uint16_t)
                filterStatus              : filter status. msB: calibrated sensors on hot, lsB: fused (uint16_t)

*/
mavlink.messages.ascl_telemetry_nav_state_regular_value = function(timems, pqr, euler, quat, acc, velNed, ned, llh, navStatus, filterStatus) {

    this.format = '<I3f3f4f3f3f3f3IHH';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_REGULAR_VALUE;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    this.crc_extra = 141;
    this.name = 'ASCL_TELEMETRY_NAV_STATE_REGULAR_VALUE';

    this.fieldnames = ['timems', 'pqr', 'euler', 'quat', 'acc', 'velNed', 'ned', 'llh', 'navStatus', 'filterStatus'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_nav_state_regular_value.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_nav_state_regular_value.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.pqr, this.euler, this.quat, this.acc, this.velNed, this.ned, this.llh, this.navStatus, this.filterStatus]));
}

/* 
Message encoding regular telemetry set

                timems                    : FC time in ms (uint32_t)
                covQuat                   : Upper triangle of P(IDX_QUAT:IDX_QUAT+3, IDX_QUAT:IDX_QUAT+3) (float)
                covDiag                   : Diagonal element of P(IDX_GYRO_BIAS:end, IDX_GYRO_BIAS:end) (float)

*/
mavlink.messages.ascl_telemetry_nav_state_regular_cov = function(timems, covQuat, covDiag) {

    this.format = '<I10f22f';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_REGULAR_COV;
    this.order_map = [0, 1, 2];
    this.crc_extra = 188;
    this.name = 'ASCL_TELEMETRY_NAV_STATE_REGULAR_COV';

    this.fieldnames = ['timems', 'covQuat', 'covDiag'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_nav_state_regular_cov.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_nav_state_regular_cov.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.covQuat, this.covDiag]));
}

/* 
Message encoding attitude-related estimation

                timems                    : FC time in ms (uint32_t)
                pqr                       : Angular rate in rad/s (float)
                euler                     : Euler angle in deg (float)
                quat                      : Quaternion (float)
                covQuat                   : Covariance of Quaternion (float)
                fused                     : Flags whether sensor(s) data is fused (uint8_t)

*/
mavlink.messages.ascl_telemetry_nav_state_att = function(timems, pqr, euler, quat, covQuat, fused) {

    this.format = '<I3f3f4f10fB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_ATT;
    this.order_map = [0, 1, 2, 3, 4, 5];
    this.crc_extra = 3;
    this.name = 'ASCL_TELEMETRY_NAV_STATE_ATT';

    this.fieldnames = ['timems', 'pqr', 'euler', 'quat', 'covQuat', 'fused'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_nav_state_att.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_nav_state_att.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.pqr, this.euler, this.quat, this.covQuat, this.fused]));
}

/* 
Message encoding position-related estimation

                timems                    : FC time in ms (uint32_t)
                acc                       : Linear acceleration in m/s2 (float)
                velNed                    : Velocity of a vehicle in NED frame in m/s (float)
                ned                       : NED position in m (float)
                llh                       : latitude/longitude/height in degE7/degE7/mm as integer (uint32_t)
                covVelPos                 : Covariance of ned velocity and ned position (float)
                fused                     : Flags whether sensor(s) data is fused (uint8_t)

*/
mavlink.messages.ascl_telemetry_nav_state_vel_pos = function(timems, acc, velNed, ned, llh, covVelPos, fused) {

    this.format = '<I3f3f3f3I21fB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_VEL_POS;
    this.order_map = [0, 1, 2, 3, 4, 5, 6];
    this.crc_extra = 114;
    this.name = 'ASCL_TELEMETRY_NAV_STATE_VEL_POS';

    this.fieldnames = ['timems', 'acc', 'velNed', 'ned', 'llh', 'covVelPos', 'fused'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_nav_state_vel_pos.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_nav_state_vel_pos.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.acc, this.velNed, this.ned, this.llh, this.covVelPos, this.fused]));
}

/* 
Message encoding navigational reference(believed to be true)

                timems                    : FC time in ms (uint32_t)
                euler                     : Euler angle in deg (float)
                llh                       : latitude/longitude/height in degE7/degE7/mm as integer (uint32_t)
                velNed                    : Velocity of a vehicle in NED frame in m/s (float)

*/
mavlink.messages.ascl_telemetry_nav_state_refernce = function(timems, euler, llh, velNed) {

    this.format = '<I3f3I3f';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_NAV_STATE_REFERNCE;
    this.order_map = [0, 1, 2, 3];
    this.crc_extra = 181;
    this.name = 'ASCL_TELEMETRY_NAV_STATE_REFERNCE';

    this.fieldnames = ['timems', 'euler', 'llh', 'velNed'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_nav_state_refernce.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_nav_state_refernce.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.euler, this.llh, this.velNed]));
}

/* 
Message encoding home position

                timems                    : FC time in ms (uint32_t)
                lat                       : Latitude in deg* 10^7 as integer (uint32_t)
                lon                       : Longitude in deg* 10^7 as integer (uint32_t)
                height                    : Height in mm as integer (uint32_t)
                state                     : Home set state. Altitude only, 3D set (uint8_t)

*/
mavlink.messages.ascl_telemetry_home = function(timems, lat, lon, height, state) {

    this.format = '<IIIIB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_HOME;
    this.order_map = [0, 1, 2, 3, 4];
    this.crc_extra = 128;
    this.name = 'ASCL_TELEMETRY_HOME';

    this.fieldnames = ['timems', 'lat', 'lon', 'height', 'state'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_home.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_home.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.lat, this.lon, this.height, this.state]));
}

/* 
Message encoding magnetometer data

                timems                    : FC time in ms (uint32_t)
                mag                       : Magnetic field in body frame in gauss (float)

*/
mavlink.messages.ascl_telemetry_sensor_mag = function(timems, mag) {

    this.format = '<I3f';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_MAG;
    this.order_map = [0, 1];
    this.crc_extra = 122;
    this.name = 'ASCL_TELEMETRY_SENSOR_MAG';

    this.fieldnames = ['timems', 'mag'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_sensor_mag.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_sensor_mag.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.mag]));
}

/* 
Message encoding imu(gyro,acc) data

                timems                    : FC time in ms (uint32_t)
                gyro                      : Angular rate in rad/s (float)
                acc                       : Linear acceleration in m/s2 (float)

*/
mavlink.messages.ascl_telemetry_sensor_imu = function(timems, gyro, acc) {

    this.format = '<I3f3f';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_IMU;
    this.order_map = [0, 1, 2];
    this.crc_extra = 124;
    this.name = 'ASCL_TELEMETRY_SENSOR_IMU';

    this.fieldnames = ['timems', 'gyro', 'acc'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_sensor_imu.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_sensor_imu.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.gyro, this.acc]));
}

/* 
Message encoding GPS data

                timems                    : FC time in ms (uint32_t)
                lat                       : Latitude in deg* 10^7 as integer (uint32_t)
                lon                       : Longitude in deg* 10^7 as integer (uint32_t)
                height                    : Height in mm as integer (uint32_t)
                velNed                    : Velocity of a vehicle in NED frame in mm/s as integer (uint32_t)
                numSats                   : Number of valid satellites (uint8_t)
                fixType                   : GPS Position fix type. 2D fix, 3D fix, etc. (uint8_t)

*/
mavlink.messages.ascl_telemetry_sensor_gps = function(timems, lat, lon, height, velNed, numSats, fixType) {

    this.format = '<IIII3IBB';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_GPS;
    this.order_map = [0, 1, 2, 3, 4, 5, 6];
    this.crc_extra = 249;
    this.name = 'ASCL_TELEMETRY_SENSOR_GPS';

    this.fieldnames = ['timems', 'lat', 'lon', 'height', 'velNed', 'numSats', 'fixType'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_sensor_gps.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_sensor_gps.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.lat, this.lon, this.height, this.velNed, this.numSats, this.fixType]));
}

/* 
Message encoding barometer data

                timems                    : FC time in ms (uint32_t)
                pressure                  : Atmospheric pressure in bar (float)
                temperature               : Ambient temperature in degree celsius (float)
                alt                       : Barometric altitude in mm as integer (uint32_t)

*/
mavlink.messages.ascl_telemetry_sensor_baro = function(timems, pressure, temperature, alt) {

    this.format = '<IffI';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_BARO;
    this.order_map = [0, 1, 2, 3];
    this.crc_extra = 193;
    this.name = 'ASCL_TELEMETRY_SENSOR_BARO';

    this.fieldnames = ['timems', 'pressure', 'temperature', 'alt'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_sensor_baro.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_sensor_baro.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.pressure, this.temperature, this.alt]));
}

/* 
Message encoding GPS/INS data. VN200 at the moment

                timems                    : FC time in ms (uint32_t)
                lat                       : Latitude in deg* 10^7 as integer (uint32_t)
                lon                       : Longitude in deg* 10^7 as integer (uint32_t)
                height                    : Height in mm as integer (uint32_t)
                velNed                    : Velocity of a vehicle in NED frame in mm/s as integer (uint32_t)
                euler                     : Euler angle in deg (float)
                gyro                      : Angular rate in rad/s (float)
                acc                       : Linear acceleration in m/s2 (float)

*/
mavlink.messages.ascl_telemetry_sensor_gps_ins = function(timems, lat, lon, height, velNed, euler, gyro, acc) {

    this.format = '<IIII3I3f3f3f';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_GPS_INS;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7];
    this.crc_extra = 238;
    this.name = 'ASCL_TELEMETRY_SENSOR_GPS_INS';

    this.fieldnames = ['timems', 'lat', 'lon', 'height', 'velNed', 'euler', 'gyro', 'acc'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_sensor_gps_ins.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_sensor_gps_ins.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.lat, this.lon, this.height, this.velNed, this.euler, this.gyro, this.acc]));
}

/* 
Message encoding collection of general sensor(s) data. Each field can
refer to any kind of sensor

                timems                    : FC time in ms (uint32_t)
                ned                       : NED position in m (float)
                llh                       : latitude/longitude/height in degE7/degE7/mm as integer (uint32_t)
                velNed                    : Velocity of a vehicle in NED frame in m/s (float)
                euler                     : Euler angle in deg (float)
                mag                       : Magnetic field in body frame in gauss (float)
                gyro                      : Angular rate in rad/s (float)
                acc                       : Linear acceleration in m/s2 (float)
                reserved1                 : Reserved space for flexible operation (float)
                reserved2                 : Reserved space for flexible operation (float)
                reserved3                 : Reserved space for flexible operation (float)
                reserved4                 : Reserved space for flexible operation (float)

*/
mavlink.messages.ascl_telemetry_sensor_general = function(timems, ned, llh, velNed, euler, mag, gyro, acc, reserved1, reserved2, reserved3, reserved4) {

    this.format = '<I3f3I3f3f3f3f3f3f3f3f3f';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_TELEMETRY_SENSOR_GENERAL;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    this.crc_extra = 214;
    this.name = 'ASCL_TELEMETRY_SENSOR_GENERAL';

    this.fieldnames = ['timems', 'ned', 'llh', 'velNed', 'euler', 'mag', 'gyro', 'acc', 'reserved1', 'reserved2', 'reserved3', 'reserved4'];


    this.set(arguments);

}
        
mavlink.messages.ascl_telemetry_sensor_general.prototype = new mavlink.message;

mavlink.messages.ascl_telemetry_sensor_general.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.timems, this.ned, this.llh, this.velNed, this.euler, this.mag, this.gyro, this.acc, this.reserved1, this.reserved2, this.reserved3, this.reserved4]));
}

/* 
Raw values of RC input

                chan1                     : RC Channel 1 Raw Value (uint16_t)
                chan2                     : RC Channel 2 Raw Value (uint16_t)
                chan3                     : RC Channel 3 Raw Value (uint16_t)
                chan4                     : RC Channel 4 Raw Value (uint16_t)
                chan5                     : RC Channel 5 Raw Value (uint16_t)
                chan6                     : RC Channel 6 Raw Value (uint16_t)
                chan7                     : RC Channel 7 Raw Value (uint16_t)
                chan8                     : RC Channel 8 Raw Value (uint16_t)
                chan9                     : RC Channel 9 Raw Value (uint16_t)
                chan10                    : RC Channel 10 Raw Value (uint16_t)
                chan11                    : RC Channel 11 Raw Value (uint16_t)
                chan12                    : RC Channel 12 Raw Value (uint16_t)
                chan13                    : RC Channel 13 Raw Value (uint16_t)
                chan14                    : RC Channel 14 Raw Value (uint16_t)
                chan15                    : RC Channel 15 Raw Value (uint16_t)
                chan16                    : RC Channel 16 Raw Value (uint16_t)

*/
mavlink.messages.ascl_rc_channels_raw = function(chan1, chan2, chan3, chan4, chan5, chan6, chan7, chan8, chan9, chan10, chan11, chan12, chan13, chan14, chan15, chan16) {

    this.format = '<HHHHHHHHHHHHHHHH';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_RC_CHANNELS_RAW;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    this.crc_extra = 194;
    this.name = 'ASCL_RC_CHANNELS_RAW';

    this.fieldnames = ['chan1', 'chan2', 'chan3', 'chan4', 'chan5', 'chan6', 'chan7', 'chan8', 'chan9', 'chan10', 'chan11', 'chan12', 'chan13', 'chan14', 'chan15', 'chan16'];


    this.set(arguments);

}
        
mavlink.messages.ascl_rc_channels_raw.prototype = new mavlink.message;

mavlink.messages.ascl_rc_channels_raw.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.chan1, this.chan2, this.chan3, this.chan4, this.chan5, this.chan6, this.chan7, this.chan8, this.chan9, this.chan10, this.chan11, this.chan12, this.chan13, this.chan14, this.chan15, this.chan16]));
}

/* 
Scaled values of RC input. -10,000(-100%) ~ 10,000(100%)

                chan1                     : RC Channel 1 Scaled Value (int16_t)
                chan2                     : RC Channel 2 Scaled Value (int16_t)
                chan3                     : RC Channel 3 Scaled Value (int16_t)
                chan4                     : RC Channel 4 Scaled Value (int16_t)
                chan5                     : RC Channel 5 Scaled Value (int16_t)
                chan6                     : RC Channel 6 Scaled Value (int16_t)
                chan7                     : RC Channel 7 Scaled Value (int16_t)
                chan8                     : RC Channel 8 Scaled Value (int16_t)
                chan9                     : RC Channel 9 Scaled Value (int16_t)
                chan10                    : RC Channel 10 Scaled Value (int16_t)
                chan11                    : RC Channel 11 Scaled Value (int16_t)
                chan12                    : RC Channel 12 Scaled Value (int16_t)
                chan13                    : RC Channel 13 Scaled Value (int16_t)
                chan14                    : RC Channel 14 Scaled Value (int16_t)
                chan15                    : RC Channel 15 Scaled Value (int16_t)
                chan16                    : RC Channel 16 Scaled Value (int16_t)

*/
mavlink.messages.ascl_rc_channels_scaled = function(chan1, chan2, chan3, chan4, chan5, chan6, chan7, chan8, chan9, chan10, chan11, chan12, chan13, chan14, chan15, chan16) {

    this.format = '<hhhhhhhhhhhhhhhh';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_RC_CHANNELS_SCALED;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    this.crc_extra = 75;
    this.name = 'ASCL_RC_CHANNELS_SCALED';

    this.fieldnames = ['chan1', 'chan2', 'chan3', 'chan4', 'chan5', 'chan6', 'chan7', 'chan8', 'chan9', 'chan10', 'chan11', 'chan12', 'chan13', 'chan14', 'chan15', 'chan16'];


    this.set(arguments);

}
        
mavlink.messages.ascl_rc_channels_scaled.prototype = new mavlink.message;

mavlink.messages.ascl_rc_channels_scaled.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.chan1, this.chan2, this.chan3, this.chan4, this.chan5, this.chan6, this.chan7, this.chan8, this.chan9, this.chan10, this.chan11, this.chan12, this.chan13, this.chan14, this.chan15, this.chan16]));
}

/* 
PWM out (from FC) to servo/motor

                chan1                     : PWM servo/motor 1 (uint16_t)
                chan2                     : PWM servo/motor 2 (uint16_t)
                chan3                     : PWM servo/motor 3 (uint16_t)
                chan4                     : PWM servo/motor 4 (uint16_t)
                chan5                     : PWM servo/motor 5 (uint16_t)
                chan6                     : PWM servo/motor 6 (uint16_t)
                chan7                     : PWM servo/motor 7 (uint16_t)
                chan8                     : PWM servo/motor 8 (uint16_t)
                chan9                     : PWM servo/motor 9 (uint16_t)
                chan10                    : PWM servo/motor 10 (uint16_t)
                chan11                    : PWM servo/motor 11 (uint16_t)
                chan12                    : PWM servo/motor 12 (uint16_t)
                chan13                    : PWM servo/motor 13 (uint16_t)
                chan14                    : PWM servo/motor 14 (uint16_t)
                chan15                    : PWM servo/motor 15 (uint16_t)
                chan16                    : PWM servo/motor 16 (uint16_t)

*/
mavlink.messages.ascl_pwm_out = function(chan1, chan2, chan3, chan4, chan5, chan6, chan7, chan8, chan9, chan10, chan11, chan12, chan13, chan14, chan15, chan16) {

    this.format = '<HHHHHHHHHHHHHHHH';
    this.id = mavlink.MAVLINK_MSG_ID_ASCL_PWM_OUT;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    this.crc_extra = 167;
    this.name = 'ASCL_PWM_OUT';

    this.fieldnames = ['chan1', 'chan2', 'chan3', 'chan4', 'chan5', 'chan6', 'chan7', 'chan8', 'chan9', 'chan10', 'chan11', 'chan12', 'chan13', 'chan14', 'chan15', 'chan16'];


    this.set(arguments);

}
        
mavlink.messages.ascl_pwm_out.prototype = new mavlink.message;

mavlink.messages.ascl_pwm_out.prototype.pack = function(mav) {
    return mavlink.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.chan1, this.chan2, this.chan3, this.chan4, this.chan5, this.chan6, this.chan7, this.chan8, this.chan9, this.chan10, this.chan11, this.chan12, this.chan13, this.chan14, this.chan15, this.chan16]));
}



mavlink.map = {
        53232: { format: '<fHB', type: mavlink.messages.ascl_param_set, order_map: [1, 0, 2], crc_extra: 117 },
        53233: { format: '<H', type: mavlink.messages.ascl_param_request, order_map: [0], crc_extra: 50 },
        53234: { format: '<fHBB', type: mavlink.messages.ascl_param_value, order_map: [1, 0, 2, 3], crc_extra: 197 },
        53248: { format: '<fffiiiHH', type: mavlink.messages.ascl_command_send_fi, order_map: [6, 7, 0, 1, 2, 3, 4, 5], crc_extra: 145 },
        53249: { format: '<ffffffHH', type: mavlink.messages.ascl_command_send_f, order_map: [6, 7, 0, 1, 2, 3, 4, 5], crc_extra: 216 },
        53250: { format: '<HB', type: mavlink.messages.ascl_command_ack, order_map: [0, 1], crc_extra: 123 },
        55296: { format: '<I3f3f4f3f3f3f3IHH', type: mavlink.messages.ascl_telemetry_nav_state_regular_value, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], crc_extra: 141 },
        55297: { format: '<I10f22f', type: mavlink.messages.ascl_telemetry_nav_state_regular_cov, order_map: [0, 1, 2], crc_extra: 188 },
        55298: { format: '<I3f3f4f10fB', type: mavlink.messages.ascl_telemetry_nav_state_att, order_map: [0, 1, 2, 3, 4, 5], crc_extra: 3 },
        55299: { format: '<I3f3f3f3I21fB', type: mavlink.messages.ascl_telemetry_nav_state_vel_pos, order_map: [0, 1, 2, 3, 4, 5, 6], crc_extra: 114 },
        55300: { format: '<I3f3I3f', type: mavlink.messages.ascl_telemetry_nav_state_refernce, order_map: [0, 1, 2, 3], crc_extra: 181 },
        55301: { format: '<IIIIB', type: mavlink.messages.ascl_telemetry_home, order_map: [0, 1, 2, 3, 4], crc_extra: 128 },
        53400: { format: '<I3f', type: mavlink.messages.ascl_telemetry_sensor_mag, order_map: [0, 1], crc_extra: 122 },
        53401: { format: '<I3f3f', type: mavlink.messages.ascl_telemetry_sensor_imu, order_map: [0, 1, 2], crc_extra: 124 },
        53402: { format: '<IIII3IBB', type: mavlink.messages.ascl_telemetry_sensor_gps, order_map: [0, 1, 2, 3, 4, 5, 6], crc_extra: 249 },
        53403: { format: '<IffI', type: mavlink.messages.ascl_telemetry_sensor_baro, order_map: [0, 1, 2, 3], crc_extra: 193 },
        53404: { format: '<IIII3I3f3f3f', type: mavlink.messages.ascl_telemetry_sensor_gps_ins, order_map: [0, 1, 2, 3, 4, 5, 6, 7], crc_extra: 238 },
        53410: { format: '<I3f3I3f3f3f3f3f3f3f3f3f', type: mavlink.messages.ascl_telemetry_sensor_general, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], crc_extra: 214 },
        53500: { format: '<HHHHHHHHHHHHHHHH', type: mavlink.messages.ascl_rc_channels_raw, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], crc_extra: 194 },
        53501: { format: '<hhhhhhhhhhhhhhhh', type: mavlink.messages.ascl_rc_channels_scaled, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], crc_extra: 75 },
        53502: { format: '<HHHHHHHHHHHHHHHH', type: mavlink.messages.ascl_pwm_out, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], crc_extra: 167 },
}


// Special mavlink message to capture malformed data packets for debugging
mavlink.messages.bad_data = function(data, reason) {
    this.id = mavlink.MAVLINK_MSG_ID_BAD_DATA;
    this.data = data;
    this.reason = reason;
    this.msgbuf = data;
}

/* MAVLink protocol handling class */
MAVLinkProcessor = function(logger, srcSystem, srcComponent) {

    this.logger = logger;

    this.seq = 0;
    this.buf = new Buffer.from([]);
    this.bufInError = new Buffer.from([]);
   
    this.srcSystem = (typeof srcSystem === 'undefined') ? 0 : srcSystem;
    this.srcComponent =  (typeof srcComponent === 'undefined') ? 0 : srcComponent;

    this.have_prefix_error = false;

    // The first packet we expect is a valid header, 6 bytes.
    if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
        this.protocol_marker = 253; //0xFD
        this.expected_length = 10;
    }
    else {
        this.protocol_marker = 254; //0xFE
        this.expected_length = 6;
    }
    this.little_endian = true;

    this.crc_extra = true;
    this.sort_fields = true;
    this.total_packets_sent = 0;
    this.total_bytes_sent = 0;
    this.total_packets_received = 0;
    this.total_bytes_received = 0;
    this.total_receive_errors = 0;
    this.startup_time = Date.now();
    
}

// Implements EventEmitter
util.inherits(MAVLinkProcessor, events.EventEmitter);

// If the logger exists, this function will add a message to it.
// Assumes the logger is a winston object.
MAVLinkProcessor.prototype.log = function(message) {
    if(this.logger) {
        this.logger.info(message);
    }
}

MAVLinkProcessor.prototype.log = function(level, message) {
    if(this.logger) {
        this.logger.log(level, message);
    }
}

MAVLinkProcessor.prototype.send = function(mavmsg) {
    buf = mavmsg.pack(this);
    this.file.write(buf);
    this.seq = (this.seq + 1) % 256;
    this.total_packets_sent +=1;
    this.total_bytes_sent += buf.length;
}

// return number of bytes needed for next parsing stage
MAVLinkProcessor.prototype.bytes_needed = function() {
    ret = this.expected_length - this.buf.length;
    return ( ret <= 0 ) ? 1 : ret;
}

// add data to the local buffer
MAVLinkProcessor.prototype.pushBuffer = function(data) {
    if(data) {
        this.buf = Buffer.concat([this.buf, data]);
        this.total_bytes_received += data.length;
    }
}

// Decode prefix.  Elides the prefix.
MAVLinkProcessor.prototype.parsePrefix = function() {

    // Test for a message prefix.
    if( this.buf.length >= 1 && this.buf[0] != this.protocol_marker ) {

        // Strip the offending initial byte and throw an error.
        var badPrefix = this.buf[0];
        this.bufInError = this.buf.slice(0,1);
        this.buf = this.buf.slice(1);
        if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
            this.expected_length = 10;
        }
        else {
            this.expected_length = 6;
        }

        // TODO: enable subsequent prefix error suppression if robust_parsing is implemented
        //if(!this.have_prefix_error) {
        //    this.have_prefix_error = true;
            throw new Error("Bad prefix ("+badPrefix+")");
        //}

    }
    //else if( this.buf.length >= 1 && this.buf[0] == this.protocol_marker ) {
    //    this.have_prefix_error = false;
    //}

}

// Determine the length.  Leaves buffer untouched.
MAVLinkProcessor.prototype.parseLength = function() {
    
    if( this.buf.length >= 2 ) {
        var unpacked = jspack.Unpack('BB', this.buf.slice(0, 2));
        if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
            this.expected_length = unpacked[1] + 12; // length of message + header + CRC
        }
        else {
            this.expected_length = unpacked[1] + 8; // length of message + header + CRC
        }
        
    }

}

// input some data bytes, possibly returning a new message
MAVLinkProcessor.prototype.parseChar = function(c) {

    var m = null;

    try {

        this.pushBuffer(c);
        this.parsePrefix();
        this.parseLength();
        m = this.parsePayload();

    } catch(e) {

        this.log('error', e.message);
        this.total_receive_errors += 1;
        m = new mavlink.messages.bad_data(this.bufInError, e.message);
        this.bufInError = new Buffer.from([]);
        
    }

    if(null != m) {
        this.emit(m.name, m);
        this.emit('message', m);
    }

    return m;

}

MAVLinkProcessor.prototype.parsePayload = function() {

    var m = null;

    // If we have enough bytes to try and read it, read it.
    if( this.expected_length >= 8 && this.buf.length >= this.expected_length ) {

        // Slice off the expected packet length, reset expectation to be to find a header.
        var mbuf = this.buf.slice(0, this.expected_length);
        // TODO: slicing off the buffer should depend on the error produced by the decode() function
        // - if a message we find a well formed message, cut-off the expected_length
        // - if the message is not well formed (correct prefix by accident), cut-off 1 char only
        this.buf = this.buf.slice(this.expected_length);
        this.expected_length = 6;

        // w.info("Attempting to parse packet, message candidate buffer is ["+mbuf.toByteArray()+"]");

        try {
            m = this.decode(mbuf);
            this.total_packets_received += 1;
        }
        catch(e) {
            // Set buffer in question and re-throw to generic error handling
            this.bufInError = mbuf;
            throw e;
        }
    }

    return m;

}

// input some data bytes, possibly returning an array of new messages
MAVLinkProcessor.prototype.parseBuffer = function(s) {
    
    // Get a message, if one is available in the stream.
    var m = this.parseChar(s);

    // No messages available, bail.
    if ( null === m ) {
        return null;
    }
    
    // While more valid messages can be read from the existing buffer, add
    // them to the array of new messages and return them.
    var ret = [m];
    while(true) {
        m = this.parseChar();
        if ( null === m ) {
            // No more messages left.
            return ret;
        }
        ret.push(m);
    }

}

/* decode a buffer as a MAVLink message */
MAVLinkProcessor.prototype.decode = function(msgbuf) {

    var magic, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent, unpacked, msgId;

    // decode the header
    try {
        if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
            unpacked = jspack.Unpack('cBBBBBBHB', msgbuf.slice(0, 10));
            magic = unpacked[0];
            mlen = unpacked[1];
            incompat_flags = unpacked[2];
            compat_flags = unpacked[3];
            seq = unpacked[4];
            srcSystem = unpacked[5];
            srcComponent = unpacked[6];
            var msgIDlow = ((unpacked[7] & 0xFF) << 8) | ((unpacked[7] >> 8) & 0xFF);
            var msgIDhigh = unpacked[8];
            msgId = msgIDlow | (msgIDhigh<<16);
        }
        else {
            unpacked = jspack.Unpack('cBBBBB', msgbuf.slice(0, 6));
            magic = unpacked[0];
            mlen = unpacked[1];
            seq = unpacked[2];
            srcSystem = unpacked[3];
            srcComponent = unpacked[4];
            msgId = unpacked[5];
        }
    }
    catch(e) {
        throw new Error('Unable to unpack MAVLink header: ' + e.message);
    }

    if (magic.charCodeAt(0) != this.protocol_marker) {
        throw new Error("Invalid MAVLink prefix ("+magic.charCodeAt(0)+")");
    }

    if( mlen != msgbuf.length - 12 && mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
        throw new Error("Invalid MAVLink message length.  Got " + (msgbuf.length - 12) + " expected " + mlen + ", msgId=" + msgId);
    }
    else if (mlen != msgbuf.length - 8 && mavlink.WIRE_PROTOCOL_VERSION == '1.0'){
        throw new Error("Invalid MAVLink message length.  Got " + (msgbuf.length - 8) + " expected " + mlen + ", msgId=" + msgId);
    }

    if( false === _.has(mavlink.map, msgId) ) {
        throw new Error("Unknown MAVLink message ID (" + msgId + ")");
    }

    // decode the payload
    // refs: (fmt, type, order_map, crc_extra) = mavlink.map[msgId]
    var decoder = mavlink.map[msgId];

    // decode the checksum
    try {
        var receivedChecksum = jspack.Unpack('<H', msgbuf.slice(msgbuf.length - 2));
    } catch (e) {
        throw new Error("Unable to unpack MAVLink CRC: " + e.message);
    }

    var messageChecksum = mavlink.x25Crc(msgbuf.slice(1, msgbuf.length - 2));

    // Assuming using crc_extra = True.  See the message.prototype.pack() function.
    messageChecksum = mavlink.x25Crc([decoder.crc_extra], messageChecksum);
    
    if ( receivedChecksum != messageChecksum ) {
        throw new Error('invalid MAVLink CRC in msgID ' +msgId+ ', got 0x' + receivedChecksum + ' checksum, calculated payload checkum as 0x'+messageChecksum );
    }

    var paylen = jspack.CalcLength(decoder.format);
    if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
        var payload = msgbuf.slice(10, msgbuf.length - 2);
    }
    else {
        var payload = msgbuf.slice(6, msgbuf.length - 2);
    }
    //put any truncated 0's back in
    if (paylen > payload.length && mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
        payload =  Buffer.concat([payload, Buffer.alloc(paylen - payload.length)]);
    }

    // Decode the payload and reorder the fields to match the order map.
    try {
        if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
            var t = jspack.Unpack(decoder.format, payload);
        }
        else {
            var t = jspack.Unpack(decoder.format, payload);
        }
    }
    catch (e) {
        if (mavlink.WIRE_PROTOCOL_VERSION == '2.0') {
            throw new Error('Unable to unpack MAVLink payload type='+decoder.type+' format='+decoder.format+' payloadLength='+ payload +': '+ e.message);
        }
        else {
            throw new Error('Unable to unpack MAVLink payload type='+decoder.type+' format='+decoder.format+' payloadLength='+ payload +': '+ e.message);
        }
    }

    // Reorder the fields to match the order map
    var args = [];
    _.each(t, function(e, i, l) {
        args[i] = t[decoder.order_map[i]]
    });

    // construct the message object
    try {
        var m = new decoder.type(args);
        m.set.call(m, args);
    }
    catch (e) {
        throw new Error('Unable to instantiate MAVLink message of type '+decoder.type+' : ' + e.message);
    }
    m.msgbuf = msgbuf;
    m.payload = payload
    m.crc = receivedChecksum;
    m.header = new mavlink.header(msgId, mlen, seq, srcSystem, srcComponent, incompat_flags, compat_flags);
    this.log(m);
    return m;
}


// Expose this code as a module
module.exports = {mavlink, MAVLinkProcessor};

